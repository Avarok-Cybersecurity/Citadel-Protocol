/*use std::collections::HashMap;
use std::io::{BufRead, BufReader, Read};
use std::ops::RangeInclusive;
use std::pin::Pin;
use std::sync::Arc;

use bytes::{BufMut, Bytes, BytesMut};
use futures::{AsyncBufRead, AsyncRead, FutureExt, Sink, SinkExt, Stream, StreamExt, TryStreamExt};
use futures::channel::mpsc::UnboundedSender;
use futures::channel::oneshot::Sender;
use futures::future::IntoStream;
use futures::stream::IntoAsyncRead;
use futures::task::{AtomicWaker, Context, Poll, Waker};
use num::Integer;
use parking_lot::{Mutex, RwLock};
use pin_project::pin_project;
use rand::prelude::{SliceRandom, ThreadRng};
use rand::Rng;
use rayon::iter::IndexedParallelIterator;
use rayon::iter::ParallelIterator;
use rayon::prelude::ParallelSlice;

use ez_pqcrypto::PostQuantumContainer;

use crate::drill_algebra::generate_packet_vector;
#[allow(dead_code, unused, missing_docs)]
use crate::net::crypt_splitter::{calculate_aes_gcm_output_length, get_aes_gcm_overhead, GroupReceiverConfig};
use crate::net::crypt_splitter::{AssertSendSyncSafe, PacketCoordinate};
use crate::prelude::{CryptError, Drill, PacketVector};

/// Generates the GROUP metadata; meant to be inscribed onto GROUP headers. This is step 0 of the async transmission process
/// Then, the buffering stage begins; this stage must be called elsewhere. Some source, S, where S: AsyncRead, is wrapped by
/// BufReader<S>. The capacity of BufReader, by default, buffers 8kb "frames" at a time. This 8kb is usually larger than 1 WAVE, and
/// as such, multiple waves will need to be created per "buffer frame". However, we must keep into consideration that the underling
/// Q-UDP uses a sliding window mechanism for transmission control. 1 window => n waves. The more successful the transmission rate,
/// the larger n becomes.
///
/// Suppose each ciphertext wavelength = k bytes (fixed; does not change). The last wavelength (remainder) is going to always be 0 < j <= k.
/// Since the underlying protocol transmits n waves per window, the number of ciphertext bytes transmitted per window, C(n), is (n-1)*k + j.
/// If C(n) < 8kb, then the entire file is buffered in v=1 iteration. If C(n) == 8kb, then we see again that it all gets buffered in V=1 iteration.
/// If C(n) > 8kb, then we need multiple iterations. The number of iterations, V(C(n)) = CEIL(C(n)/8kb), where CEIL is the division ceiling function
/// (Note: 8kb = 8 * 2^10 bytes). More generally, for any buffer frame of fixed byte-length F, V(C(n)) = CEIL(C(n)/F)
///
/// Since the Q-UDP window size may very well eclipse F, then multiple iterations of v in V (e.g., v= 1,2,3 ... u) may occur. Suppose the window size
/// is W. Since F is relatively small with respect to modern data transmission rates, W should be a (whole) integer that occupies u iterations of V
/// per window-send.
///
/// With this said, in order to make an asynchronous version of the crypt splitter, we must change the operation of the transmitter and receiver side.
/// The transmitter side will start-off by calling the function below in order to generate the GROUP header. From there, the transmitter-side will
/// transmit the GROUP header and wait for the GROUP header ACK. Then, the following process will occur:
///
/// 0. (start W = 1 => 8kb (TCP does 3kb))
///
/// 1. let Z = C(n)
///
/// 2. buffer min(Z, F) bytes into memory (memory_buffer)
/// 3. update Z = Z - min(Z, F)
/// 4. scramble_encrypt(memory_buffer)
/// 5. transmit waves generated by scramble_encrypt(memory_buffer)
/// 6. wait for transmission, including all possible retransmissions. Then, obtain W' (W prime. This value will automatically be generated by the transmitter, and will account for latency)
///
/// if Z == 0, done
/// else if Z > 0, GOTO step 2

pub fn generate_group_metadata(plain_text_length: usize, max_bytes_per_packet: usize, max_packets_per_wave: usize, header_size_bytes: usize) -> GroupReceiverConfig {
    let max_packet_payload_size = max_bytes_per_packet;

    //let max_packets_per_wave = drill.get_multiport_width();
    //let max_bytes_per_wave = max_packets_per_wave * max_packet_payload_size;

    let aes_gcm_overhead = get_aes_gcm_overhead();
    // the below accounts for the stretch in size as we map n plaintext bytes to calculate_aes_gcm_output_length(n) bytes
    let max_plaintext_bytes_per_packet = max_packet_payload_size; // We do not subtract the overhead, because this is the MAX. The min is max_packet_payload_size - aes_gcm_overhead, which only applies to a single packet in the wave (we account for this next)
    // Since we run the encryption algorithm once per wave, to get the number of plaintext bytes per wave we need, multiple the above by the max packets per wave and subtract
    let max_plaintext_bytes_per_wave = (max_plaintext_bytes_per_packet * max_packets_per_wave) - aes_gcm_overhead; // We encrypt this many bytes per wave

    // the "number_of_waves" is the number of full waves plus partial waves (max n=1 partial waves)
    let (number_of_full_waves, number_of_partial_waves, bytes_in_last_wave) = if plain_text_length < max_plaintext_bytes_per_wave {
        let (_, bytes_in_last_wave) = plain_text_length.div_rem(&max_plaintext_bytes_per_wave);
        (0, 1, bytes_in_last_wave)
    } else if plain_text_length % max_plaintext_bytes_per_wave == 0 {
        // in this case, there will be n full wave, 0 partial waves, thus 1 total wave, and 0 bytes in last wave.
        let number_of_full_waves = plain_text_length / max_plaintext_bytes_per_wave;
        (number_of_full_waves, 0, max_plaintext_bytes_per_wave)
    } else {
        let (number_of_full_waves, bytes_in_last_wave) = plain_text_length.div_rem(&max_plaintext_bytes_per_wave);
        // since we are not in the == case, and instead are in the > case, there will necessarily be 1 partial wave
        let number_of_partial_waves = 1;
        (number_of_full_waves, number_of_partial_waves, bytes_in_last_wave)
    };

    let number_of_waves = number_of_full_waves + number_of_partial_waves;
    // calculate buffer per full wave
    let ciphertext_len_per_full_wave = calculate_aes_gcm_output_length(max_plaintext_bytes_per_wave);
    let buffer_len_per_full_wave = ciphertext_len_per_full_wave + (max_packets_per_wave * header_size_bytes);
    // calculate buffer of last wave. In the case of plain_text.len() == max_plaintext_bytes, we have 1 wave.
    let ciphertext_len_last_wave = if number_of_partial_waves != 0 {
        calculate_aes_gcm_output_length(bytes_in_last_wave)
    } else {
        // this will ensure that the calculation below is adjusted for the equals case
        // Also, adjust the bytes in the last wave. Since there is no partial wave, but n full waves, the last
        // bytes in the last wave is equal to the amount in the full wave. This allows the buffer to be calculated correctly,
        // and at the same time allows the last wave size to be accurate
        0
    };

    let packets_in_last_wave = ciphertext_len_last_wave.div_ceil(&max_packet_payload_size);
    let buffer_len_in_last_wave = ciphertext_len_last_wave + (packets_in_last_wave * header_size_bytes);
    //println!("(buffer_len_per_full_wave{}*number_of_full_waves{}) + buffer_len_in_last_wave{} && total num waves: {}", buffer_len_per_full_wave, number_of_full_waves, buffer_len_in_last_wave, number_of_waves);
    let total_buffer_len = (buffer_len_per_full_wave * number_of_full_waves) + buffer_len_in_last_wave;

    let total_packets = (max_packets_per_wave * number_of_full_waves) + packets_in_last_wave;
    //let mut packets = HashMap::with_capacity(total_packets);
    //let mut unified_buffer_slab = BytesMut::with_capacity(total_buffer_len);

    let (_normal_packets_in_last_wave, mut debug_last_payload_size) = ciphertext_len_last_wave.div_rem(&max_packet_payload_size);
    if debug_last_payload_size == 0 {
        debug_last_payload_size = max_packet_payload_size;
    }

    debug_assert_ne!(bytes_in_last_wave, 0);

    GroupReceiverConfig::new(total_packets, header_size_bytes, plain_text_length, max_packet_payload_size, debug_last_payload_size, number_of_waves, max_plaintext_bytes_per_wave, bytes_in_last_wave, max_packets_per_wave, packets_in_last_wave)
}

pub struct AsyncCryptScramblerInner<S: Read, F: Fn(&PacketVector, &Drill, u64, &mut BytesMut) + Send + Sync> {
    input: BufReader<S>,
    scramble_params: ScrambleParams<F>,
    packets_in_ram: Arc<Vec<PacketCoordinate>>,
    window_size: RangeInclusive<usize>,
    polls_needed: usize,
    // keeps track of how many plaintext bytes have been processed
    polls_finished: usize
}

unsafe impl<S: Read, F: Fn(&PacketVector, &Drill, u64, &mut BytesMut) + Send + Sync> Send for AsyncCryptScrambler<S, F> {}
unsafe impl<S: Read, F: Fn(&PacketVector, &Drill, u64, &mut BytesMut) + Send + Sync> Sync for AsyncCryptScrambler<S, F> {}

//impl<S: AsyncRead + Unpin, O: Sink<Bytes>, T: Sink<Bytes>> Unpin for AsyncCryptScramblerInner<S, O, T> {}

pub struct AsyncCryptScrambler<S: Read, F: Fn(&PacketVector, &Drill, u64, &mut BytesMut) + Send + Sync> {
    inner: Arc<Mutex<AsyncCryptScramblerInner<S, F>>>
}

impl<S: Read, F: Fn(&PacketVector, &Drill, u64, &mut BytesMut) + Send + Sync> AsyncCryptScrambler<S, F> {
    /// Creates a new instance of [AsyncCryptSplitter]. Before starting transmission, this should be called. Then, take the returned
    /// [GroupReceiverConfig] and inscribe it into the GROUP HEADER packet. Finally, u
    pub fn new(input: S, post_quantum: PostQuantumContainer, drill: Drill, plaintext_length: usize, max_bytes_per_packet: usize, max_packets_per_wave: usize, header_byte_size: usize, group_id: u64, header_inscriber: F) -> (Self, GroupReceiverConfig) {
        let group_receiver_config = generate_group_metadata(plaintext_length, max_bytes_per_packet, max_packets_per_wave, header_byte_size);
        let grc = group_receiver_config.clone();
        let waves_in_group = grc.wave_count;
        const BUFFER_LEN: usize = 1024 * 8; // 8kb
        let input = BufReader::with_capacity(BUFFER_LEN, input);

        let target_cid = drill.get_cid();
        let max_waves_per_window = BUFFER_LEN.div_ceil(&grc.max_plaintext_wave_length);
        let window_size = 0..=std::cmp::min(max_waves_per_window, waves_in_group);
        let polls_needed = waves_in_group.div_ceil(&max_waves_per_window);
        let polls_finished = 0;
        log::trace!(target: "lusna", "Window size: {:?} | Total Polls: {}", window_size, polls_needed);
        log::trace!(target: "lusna", "BUFFER: {} | Max plaintext wavelength: {} | Max waves per window (div ceil): {}", BUFFER_LEN, grc.max_plaintext_wave_length, max_waves_per_window);

        let scramble_params = ScrambleParams {
            grc: grc.clone(),
            post_quantum,
            group_id,
            target_cid,
            drill,
            header_inscriber,
            max_waves_per_window,
        };

        let packets_in_ram = Arc::new(Vec::with_capacity(0));

        let inner = AsyncCryptScramblerInner { packets_in_ram, waker, polls_needed, polls_finished, input, scramble_params, window_size };

        (Self { inner: Arc::new(Mutex::new(inner)) }, grc)
    }

    pub fn poll_scramble(&self, cx: &mut Context<'_>) -> Poll<Option<Arc<Vec<PacketCoordinate>>>> {
        let mut this_orig = self.inner.lock();

        let wave_start = *this_orig.window_size.start();
        let wave_end = wave_start + *this_orig.window_size.end();
        let wave_range = wave_end - wave_start + 1;

        let params = &this_orig.scramble_params;
        let params_ptr = params as *const ScrambleParams<F>;

        let max_waves_per_window = params.max_waves_per_window;

        // We are given a window with n waves. By necessity, the range of the supplied waves
        // must account for a multiple of the BUFFER_LEN unless we are on the last one. This
        // BUFFER_LEN is implicit within max_waves_per_window.
        // Using div_ceil, if wave_range <= max_waves_per_window, we poll once
        // else if greater, we poll the ceiling number of times as expected
        let polls_required_this_iter = wave_range.div_ceil(&max_waves_per_window);
        log::trace!(target: "lusna", "Will poll {} times this round", polls_required_this_iter);
        let packets_this_window = (0..polls_required_this_iter).into_iter().map(|poll_idx| {
            let (bytes_read, ret) = match this_orig.input.fill_buf() {
                Ok(data) => {
                    let data: &[u8] = data;
                    let len = data.len();
                    let wave_start = wave_start + poll_idx * max_waves_per_window;
                    log::trace!(target: "lusna", "Starting to scramble wave_start: {}..", wave_start);
                    let params = unsafe { &*params_ptr };
                    (len, par_scramble_encrypt_window(data, wave_start, params))
                }

                _ => {
                    panic!("poll_fill_buf error")
                }
            };
            this_orig.input.consume(bytes_read);
            ret
        }).flatten().collect::<Vec<PacketCoordinate>>();


        this_orig.packets_in_ram = Arc::new(packets_this_window);
        let cloned = this_orig.packets_in_ram.clone();
        this_orig.polls_finished += polls_required_this_iter;
        if this_orig.polls_finished != this_orig.polls_needed {
            Poll::Ready(Some(cloned))
        } else {
            log::trace!(target: "lusna", "Finished encrypting + scrambling all the data! Ending stream");
            Poll::Ready(None)
        }
    }
}

struct ScrambleParams<F: Fn(&PacketVector, &Drill, u64, &mut BytesMut) + Send + Sync> {
    pub grc: GroupReceiverConfig,
    pub post_quantum: PostQuantumContainer,
    pub group_id: u64,
    pub target_cid: u64,
    pub drill: Drill,
    pub max_waves_per_window: usize,
    pub header_inscriber: F,
}

fn par_scramble_encrypt_window<F: Fn(&PacketVector, &Drill, u64, &mut BytesMut) + Send + Sync>(input: &[u8], start_wave_idx: usize, params: &ScrambleParams<F>) -> Vec<PacketCoordinate> {
    let group_id = params.group_id;
    let target_cid = params.target_cid;
    let max_plaintext_wave_length = params.grc.max_plaintext_wave_length;
    let max_packet_payload_size = params.grc.max_payload_size;
    let header_size_bytes = params.grc.header_size_bytes;
    let max_packets_per_wave = params.grc.max_packets_per_wave;
    let quantum_container = AssertSendSyncSafe::wrap(&params.post_quantum);
    let drill = &params.drill;
    let header_inscriber = &params.header_inscriber;

    input.par_chunks(max_plaintext_wave_length).enumerate().map(|(rel_window_wave_idx, bytes_to_encrypt_for_this_wave)| {
        let wave_idx = rel_window_wave_idx + start_wave_idx;
        let mut packets = drill.aes_gcm_encrypt(wave_idx, quantum_container.for_ref(), bytes_to_encrypt_for_this_wave).unwrap()
            .chunks(max_packet_payload_size).enumerate().map(|(relative_packet_idx, ciphertext_packet_bytes)| {
            debug_assert_ne!(ciphertext_packet_bytes.len(), 0);
            let mut packet = BytesMut::with_capacity(ciphertext_packet_bytes.len() + header_size_bytes);
            let true_packet_sequence = (wave_idx * max_packets_per_wave) + relative_packet_idx;
            let vector = generate_packet_vector(true_packet_sequence, group_id, drill);
            header_inscriber(&vector, drill, target_cid, &mut packet);
            packet.put(ciphertext_packet_bytes);
            let packet = packet.freeze();
            PacketCoordinate { packet, vector }
        }).collect::<Vec<PacketCoordinate>>();
        let mut rng = &mut ThreadRng::default();
        packets.shuffle(rng);
        packets
    }).flatten().collect::<Vec<PacketCoordinate>>()
}
*/