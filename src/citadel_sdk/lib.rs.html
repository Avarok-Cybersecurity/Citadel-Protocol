<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Source of the Rust file `citadel_sdk/src/lib.rs`."><title>lib.rs - source</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-6b053e98.ttf.woff2,FiraSans-Italic-81dc35de.woff2,FiraSans-Regular-0fe48ade.woff2,FiraSans-MediumItalic-ccf7e434.woff2,FiraSans-Medium-e1aa3f0a.woff2,SourceCodePro-Regular-8badfe75.ttf.woff2,SourceCodePro-Semibold-aa29a496.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../../static.files/normalize-9960930a.css"><link rel="stylesheet" href="../../static.files/rustdoc-1a91846b.css"><meta name="rustdoc-vars" data-root-path="../../" data-static-root-path="../../static.files/" data-current-crate="citadel_sdk" data-themes="" data-resource-suffix="" data-rustdoc-version="1.88.0 (6b00bc388 2025-06-23)" data-channel="1.88.0" data-search-js="search-f7877310.js" data-settings-js="settings-5514c975.js" ><script src="../../static.files/storage-4e99c027.js"></script><script defer src="../../static.files/src-script-63605ae7.js"></script><script defer src="../../src-files.js"></script><script defer src="../../static.files/main-7ef8a74a.js"></script><noscript><link rel="stylesheet" href="../../static.files/noscript-893ab5e7.css"></noscript><link rel="icon" href="favicon.png"></head><body class="rustdoc src"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="sidebar"><div class="src-sidebar-title"><h2>Files</h2></div></nav><div class="sidebar-resizer"></div><main><rustdoc-search></rustdoc-search><section id="main-content" class="content"><div class="main-heading"><h1><div class="sub-heading">citadel_sdk/</div>lib.rs</h1><rustdoc-toolbar></rustdoc-toolbar></div><div class="example-wrap digits-3"><pre class="rust"><code><a href=#1 id=1 data-nosnippet>1</a><span class="attr">#![doc(html_logo_url = <span class="string">"avarok.png"</span>, html_favicon_url = <span class="string">"favicon.png"</span>)]
<a href=#2 id=2 data-nosnippet>2</a></span><span class="doccomment">//! Software development kit for creating high performance, extremely-secure, and post-quantum network applications. Supports p2p (NAT traversal + WebRTC) and standard client/server architectures for
<a href=#3 id=3 data-nosnippet>3</a>//! messaging and streaming. The underlying asynchronous runtime is [Tokio](https://tokio.rs).
<a href=#4 id=4 data-nosnippet>4</a>//!
<a href=#5 id=5 data-nosnippet>5</a>//! The Network protocol, SDK, and user libraries use 100% safe rust
<a href=#6 id=6 data-nosnippet>6</a>//!
<a href=#7 id=7 data-nosnippet>7</a>//! All peer-discovery and NAT traversal are built-in to the protocol, with the central server acting as a broker and authenticator. The central server is used for TURN-like routing when direct p2p NAT traversal fails between two nodes.
<a href=#8 id=8 data-nosnippet>8</a>//!
<a href=#9 id=9 data-nosnippet>9</a>//! Authentication to a central node is required before making peer-to-peer connections. There is both device-dependent auth as well as credentialed authentication backed by the argon2id hashing algorithm.
<a href=#10 id=10 data-nosnippet>10</a>//!
<a href=#11 id=11 data-nosnippet>11</a>//! Client/Peer information is by default synchronized to the local filesystem. If the *redis* and/or *sql* feature is enabled, a redis or SQL (MySQL, PostgreSQL, SQLite) server or cluster can be used instead.
<a href=#12 id=12 data-nosnippet>12</a>//!
<a href=#13 id=13 data-nosnippet>13</a>//! When messaging is used, perfect forward secrecy (PFS) is an optional mode on a per-session basis. Best-effort mode (BEM) is also available if the security of PFS is not needed, and instead, high throughput
<a href=#14 id=14 data-nosnippet>14</a>//! in messaging is required.
<a href=#15 id=15 data-nosnippet>15</a>//!
<a href=#16 id=16 data-nosnippet>16</a>//! Client-to-server connections can use TCP, TLS (default), or QUIC protocols for the underlying communication. Cryptographers recommend the use of hybrid protocols, and as such, TLS is the default to
<a href=#17 id=17 data-nosnippet>17</a>//! ensure implementations of post-quantum networks are at least as secure as traditional methods. Valid certificates can be specified when constructing the application, otherwise, self-signed certificates are used for the underlying protocol.
<a href=#18 id=18 data-nosnippet>18</a>//!
<a href=#19 id=19 data-nosnippet>19</a>//! Peer-to-peer connections only use QUIC. In order to establish a direct peer-to-peer connection, UDP NAT-traversal is required, and as such, the use of QUIC complements this requirement since QUIC uses UDP for ordered, reliable transport.
<a href=#20 id=20 data-nosnippet>20</a>//!
<a href=#21 id=21 data-nosnippet>21</a>//! Streaming is also available in this crate. When the use of webrtc is desired for an application, the *webrtc* feature can be enabled to allow interoperability between the [`UdpChannel`] and the [WebRTC.rs](https://webrtc.rs) ecosystem.
<a href=#22 id=22 data-nosnippet>22</a>//!
<a href=#23 id=23 data-nosnippet>23</a>//! # Feature Flags
<a href=#24 id=24 data-nosnippet>24</a>//! - `multi-threaded`: Uses a multi-threaded (Send) executor for the inner protocol
<a href=#25 id=25 data-nosnippet>25</a>//! - `redis`: Enables the use of Redis for the backend
<a href=#26 id=26 data-nosnippet>26</a>//! - `sql`: Enables the use of sql for the backend
<a href=#27 id=27 data-nosnippet>27</a>//! - `webrtc`: enables *limited* interoperability with webrtc via the [`UdpChannel`] (see: [UdpChannel::into_webrtc_compat](crate::prelude::UdpChannel::into_webrtc_compat))
<a href=#28 id=28 data-nosnippet>28</a>//!
<a href=#29 id=29 data-nosnippet>29</a>//!
<a href=#30 id=30 data-nosnippet>30</a>//! # Post-quantum key encapsulation mechanisms
<a href=#31 id=31 data-nosnippet>31</a>//! The user may also select a KEM family before a session to either a central server or peer begins (see: [SessionSecuritySettingsBuilder](crate::prelude::SessionSecuritySettingsBuilder)). Each KEM has variants that alter the degree of security
<a href=#32 id=32 data-nosnippet>32</a>//! - Kyber (default)
<a href=#33 id=33 data-nosnippet>33</a>//! - NTRU (Sntrup761)
<a href=#34 id=34 data-nosnippet>34</a>//!
<a href=#35 id=35 data-nosnippet>35</a>//! # Encryption Algorithms
<a href=#36 id=36 data-nosnippet>36</a>//! The user may also select a symmetric encryption algorithm before a session starts (see: [SessionSecuritySettingsBuilder](crate::prelude::SessionSecuritySettingsBuilder))
<a href=#37 id=37 data-nosnippet>37</a>//!
<a href=#38 id=38 data-nosnippet>38</a>//! - AES-256-GCM
<a href=#39 id=39 data-nosnippet>39</a>//! - Chacha20Poly-1305
<a href=#40 id=40 data-nosnippet>40</a>//! - Ascon-80pq
<a href=#41 id=41 data-nosnippet>41</a>//! - Kyber Hybrid Encryption (see below for explanation)
<a href=#42 id=42 data-nosnippet>42</a>//!
<a href=#43 id=43 data-nosnippet>43</a>//! Whereas AES-GCM and ChaCha are only quantum resistant (as opposed to post-quantum), a novel method of encryption may be used that
<a href=#44 id=44 data-nosnippet>44</a>//! combines the post-quantum asymmetric encryption algorithm Kyber coupled with AES. When Kyber Hybrid Encryption is used, several modifications to the protocol outlined in the whitepaper
<a href=#45 id=45 data-nosnippet>45</a>//! is applied. The first modification is the use of Falcon-1024 to sign each message to ensure non-repudiation. The second modification is more complex. Ciphertext is first encrypted by AES-GCM, then, randomly shifted using modular arithmetic
<a href=#46 id=46 data-nosnippet>46</a>//! in 32-byte blocks using a 32-byte long quasi one-time pad (OTP). The OTP is unique for each ciphertext, and, is appended at the end of the ciphertext in encrypted form (using Kyber1024 encryption). Even if the attacker uses Grover's algorithm to
<a href=#47 id=47 data-nosnippet>47</a>//! discover the AES key, the attacker would also have to break the lattice-based Kyber cryptography in order to properly order
<a href=#48 id=48 data-nosnippet>48</a>//! the ciphertext before using the AES key. Since every 32 bytes of input into the Kyber encryption scheme produces over a 1KB output ciphertext, and, each quasi-OTP is 32 bytes long,
<a href=#49 id=49 data-nosnippet>49</a>//! the size of each packet is increased at a minimum constant value, helping keep packet sizes minimal and security very high.
<a href=#50 id=50 data-nosnippet>50</a>//!
<a href=#51 id=51 data-nosnippet>51</a>//! # Network Architecture
<a href=#52 id=52 data-nosnippet>52</a></span><span class="attr">#![cfg_attr(
<a href=#53 id=53 data-nosnippet>53</a>    feature = <span class="string">"doc-images"</span>,
<a href=#54 id=54 data-nosnippet>54</a>    doc = <span class="macro">::embed_doc_image::embed_image!</span>(
<a href=#55 id=55 data-nosnippet>55</a>    <span class="string">"network_direct_p2p"</span>,
<a href=#56 id=56 data-nosnippet>56</a>    <span class="string">"../resources/network_direct_p2p.png"
<a href=#57 id=57 data-nosnippet>57</a>    </span>)
<a href=#58 id=58 data-nosnippet>58</a>)]
<a href=#59 id=59 data-nosnippet>59</a></span><span class="doccomment">//! ![Network Architecture w/ direct P2P][network_direct_p2p]
<a href=#60 id=60 data-nosnippet>60</a>//! Each network has a central node that peers may connect to. This central node helps facilitate P2P connections, and, can itself serve
<a href=#61 id=61 data-nosnippet>61</a>//! as a peer on a network if the program implementation on the central server so chooses.
<a href=#62 id=62 data-nosnippet>62</a>//!
<a href=#63 id=63 data-nosnippet>63</a>//! The peers Alice and Bob can only connect to each other after they use the central server to **register** to each other. Once registered, the two peers
<a href=#64 id=64 data-nosnippet>64</a>//! may begin attempting connecting to each other via NAT traversal. Each peer begins NAT traversal by attempting to determine what type of NAT
<a href=#65 id=65 data-nosnippet>65</a>//! they're each behind by communicating to 3 different STUN servers to find a predictable pattern in their internal/external socket mappings.
<a href=#66 id=66 data-nosnippet>66</a>//! If at least one has a predictable pattern, a direct P2P connection bypassing the central server may be facilitated.
<a href=#67 id=67 data-nosnippet>67</a>//!
<a href=#68 id=68 data-nosnippet>68</a>//! If, however, both Alice and Bob do not have predictable internal/external socket mappings (e.g., both are behind symmetric NATs), then, both will use
<a href=#69 id=69 data-nosnippet>69</a>//! their central server to relay their packets to each other using endpoint-to-endpoint encryption, preventing the central server from
<a href=#70 id=70 data-nosnippet>70</a>//! decrypting the packets.
<a href=#71 id=71 data-nosnippet>71</a>//!
<a href=#72 id=72 data-nosnippet>72</a></span><span class="attr">#![cfg_attr(
<a href=#73 id=73 data-nosnippet>73</a>    feature = <span class="string">"doc-images"</span>,
<a href=#74 id=74 data-nosnippet>74</a>    doc = <span class="macro">::embed_doc_image::embed_image!</span>(
<a href=#75 id=75 data-nosnippet>75</a>    <span class="string">"network_relay_p2p"</span>,
<a href=#76 id=76 data-nosnippet>76</a>    <span class="string">"../resources/network_relay_p2p.png"
<a href=#77 id=77 data-nosnippet>77</a>    </span>)
<a href=#78 id=78 data-nosnippet>78</a>)]
<a href=#79 id=79 data-nosnippet>79</a></span><span class="doccomment">//! ![Network Architecture w/ relay P2P][network_relay_p2p]
<a href=#80 id=80 data-nosnippet>80</a>//!
<a href=#81 id=81 data-nosnippet>81</a>//!
<a href=#82 id=82 data-nosnippet>82</a>//! # Executor Architecture: The [`NetKernel`]
<a href=#83 id=83 data-nosnippet>83</a></span><span class="attr">#![cfg_attr(
<a href=#84 id=84 data-nosnippet>84</a>    feature = <span class="string">"doc-images"</span>,
<a href=#85 id=85 data-nosnippet>85</a>    doc = <span class="macro">::embed_doc_image::embed_image!</span>(
<a href=#86 id=86 data-nosnippet>86</a>        <span class="string">"proto_kernel_iface"</span>,
<a href=#87 id=87 data-nosnippet>87</a>        <span class="string">"../resources/proto_kernel_iface.png"
<a href=#88 id=88 data-nosnippet>88</a>    </span>)
<a href=#89 id=89 data-nosnippet>89</a>)]
<a href=#90 id=90 data-nosnippet>90</a></span><span class="doccomment">//! ![Protocol/Executor/NetKernel Architecture][proto_kernel_iface]
<a href=#91 id=91 data-nosnippet>91</a>//! Any node in the network may act as **both** a server and a client/peer (except for when [`NodeType::Peer`] or the default node type is specified). Since multiple parallel connections may exist, handling events is necessary. When the lower-level protocol produces events,
<a href=#92 id=92 data-nosnippet>92</a>//! they are sent to the [`NetKernel`]. The [`NetKernel`] is where your application logic must be written.
<a href=#93 id=93 data-nosnippet>93</a>//!
<a href=#94 id=94 data-nosnippet>94</a>//! ## Initialization Stage: The [`KernelExecutor`] and the [`NodeRemote`]
<a href=#95 id=95 data-nosnippet>95</a>//! When the node is built and awaited (as seen in the examples below), the node creates a [`NodeRemote`] which is used to communicate between the [`NetKernel`] and the lower level networking protocol. Then, the [`KernelExecutor`] passes the remote to [`NetKernel::load_remote`] (which uses a mutable reference to
<a href=#96 id=96 data-nosnippet>96</a>//! the kernel itself to allow mutation of the inner data, effectively ensuring that the remote may be stored without need of atomics, as well as any other config). Thereafter, the [`KernelExecutor`] calls [`NetKernel::on_start`] (uses an ``&amp;self`` reference) where any first asynchronous calls using the remote itself may be made.
<a href=#97 id=97 data-nosnippet>97</a>//!
<a href=#98 id=98 data-nosnippet>98</a>//! ## Passive Stage
<a href=#99 id=99 data-nosnippet>99</a>//! As the protocol generates events, the developer may choose to add program logic to react to the events. When an event is sent from the protocol to the [`KernelExecutor`], the [`KernelExecutor`] executes [`NetKernel::on_node_event_received`], passing the new event. Importantly,
<a href=#100 id=100 data-nosnippet>100</a>//! every call to [`NetKernel::on_node_event_received`] is executed *concurrently* (**not** to be confused with *parallel*), allowing the developer to react to each event separately without having to await completion before handling the next event. If an error is returned from [`NetKernel::on_node_event_received`], then the [`KernelExecutor`] will attempt
<a href=#101 id=101 data-nosnippet>101</a>//! a graceful shutdown of the protocol and any running sessions. Errors returned from [`NetKernel::on_node_event_received`] are propagated to the initial awaited call site on the node.
<a href=#102 id=102 data-nosnippet>102</a>//!
<a href=#103 id=103 data-nosnippet>103</a>//! Important note: Since [`NetKernel::on_node_event_received`] takes self by reference and is executed concurrently, [`NetKernel`] requires that ``Self: Sync`` since by definition, if ``&amp;T: Send``, then ``T: Sync``
<a href=#104 id=104 data-nosnippet>104</a>//!
<a href=#105 id=105 data-nosnippet>105</a>//! ## Shutdown stage
<a href=#106 id=106 data-nosnippet>106</a>//! Whether through an error, or, a call to [`NodeRemote::shutdown`], the [`KernelExecutor`] will call [`NetKernel::on_stop`] (which is passed an &amp;mut). During and after the execution of [`NetKernel::on_stop`], no more calls to [`NetKernel::on_node_event_received`] will occur. Any errors returned from [`NetKernel::on_stop`] will be propagated
<a href=#107 id=107 data-nosnippet>107</a>//! to the initial awaited call site on the node. Execution is complete, returning the initial kernel on success
<a href=#108 id=108 data-nosnippet>108</a>//!
<a href=#109 id=109 data-nosnippet>109</a>//! # Examples
<a href=#110 id=110 data-nosnippet>110</a>//!
<a href=#111 id=111 data-nosnippet>111</a>//! ## Server
<a href=#112 id=112 data-nosnippet>112</a>//! When building either a client/peer or server node, a [`NetKernel`] is expected. In the case below, an EmptyKernel is used that does no additional processing of inbound connections:
<a href=#113 id=113 data-nosnippet>113</a>//! ```
<a href=#114 id=114 data-nosnippet>114</a>//! use citadel_sdk::prelude::*;
<a href=#115 id=115 data-nosnippet>115</a>//! use citadel_sdk::prefabs::server::empty::EmptyKernel;
<a href=#116 id=116 data-nosnippet>116</a>//!
<a href=#117 id=117 data-nosnippet>117</a>//! // this server will listen on 127.0.0.1:25021, and will use the built-in defaults. When calling 'build', a NetKernel is specified
<a href=#118 id=118 data-nosnippet>118</a>//! let server = DefaultNodeBuilder::default()
<a href=#119 id=119 data-nosnippet>119</a>//! .with_node_type(NodeType::server("127.0.0.1:25021")?)
<a href=#120 id=120 data-nosnippet>120</a>//! .build(EmptyKernel::default())?;
<a href=#121 id=121 data-nosnippet>121</a>//!
<a href=#122 id=122 data-nosnippet>122</a>//! // await the server to execute
<a href=#123 id=123 data-nosnippet>123</a>//! # async move {
<a href=#124 id=124 data-nosnippet>124</a>//! let result = server.await;
<a href=#125 id=125 data-nosnippet>125</a>//! # };
<a href=#126 id=126 data-nosnippet>126</a>//! # Ok::&lt;(), Box&lt;dyn std::error::Error&gt;&gt;(())
<a href=#127 id=127 data-nosnippet>127</a>//! ```
<a href=#128 id=128 data-nosnippet>128</a>//!
<a href=#129 id=129 data-nosnippet>129</a>//! ## Client/Peer
<a href=#130 id=130 data-nosnippet>130</a>//! This client will connect to the server above. It will first register (if the account is not yet registered), and thereafter, connect to the server, calling the provided future to handle the received channel
<a href=#131 id=131 data-nosnippet>131</a>//! ```
<a href=#132 id=132 data-nosnippet>132</a>//! use citadel_sdk::prefabs::client::single_connection::SingleClientServerConnectionKernel;
<a href=#133 id=133 data-nosnippet>133</a>//! use futures::StreamExt;
<a href=#134 id=134 data-nosnippet>134</a>//! use citadel_sdk::prelude::*;
<a href=#135 id=135 data-nosnippet>135</a>//!
<a href=#136 id=136 data-nosnippet>136</a>//! let server_connection_settings = DefaultServerConnectionSettingsBuilder::credentialed_registration("127.0.0.1:25021", "john.doe", "John Doe", "password").build()?;
<a href=#137 id=137 data-nosnippet>137</a>//!
<a href=#138 id=138 data-nosnippet>138</a>//! let client_kernel = SingleClientServerConnectionKernel::new(server_connection_settings, |conn| async move {
<a href=#139 id=139 data-nosnippet>139</a>//!     // handle program logic here
<a href=#140 id=140 data-nosnippet>140</a>//!     let (sink, mut stream) = conn.split();
<a href=#141 id=141 data-nosnippet>141</a>//!     while let Some(message) = stream.next().await {
<a href=#142 id=142 data-nosnippet>142</a>//!         // message received in the form of a SecBuffer (memory-protected)
<a href=#143 id=143 data-nosnippet>143</a>//!     }
<a href=#144 id=144 data-nosnippet>144</a>//!
<a href=#145 id=145 data-nosnippet>145</a>//!     Ok(())
<a href=#146 id=146 data-nosnippet>146</a>//! });
<a href=#147 id=147 data-nosnippet>147</a>//!
<a href=#148 id=148 data-nosnippet>148</a>//! let client = DefaultNodeBuilder::default().build(client_kernel)?;
<a href=#149 id=149 data-nosnippet>149</a>//! # async move {
<a href=#150 id=150 data-nosnippet>150</a>//! let result = client.await;
<a href=#151 id=151 data-nosnippet>151</a>//! # };
<a href=#152 id=152 data-nosnippet>152</a>//! # Ok::&lt;(), Box&lt;dyn std::error::Error&gt;&gt;(())
<a href=#153 id=153 data-nosnippet>153</a>//! ```
<a href=#154 id=154 data-nosnippet>154</a>//!
<a href=#155 id=155 data-nosnippet>155</a>//! ## Remote Encrypted Virtual Filesystem (RE-VFS)
<a href=#156 id=156 data-nosnippet>156</a>//! The RE-VFS allows clients, servers, and peers to treat each other as remote endpoints for encrypted file storage.
<a href=#157 id=157 data-nosnippet>157</a>//! Since encrypting data locally using a symmetric key poses a vulnerability if the local node is compromised, The
<a href=#158 id=158 data-nosnippet>158</a>//! Citadel Protocol solves this issue by using a local 1024-Kyber public key to encrypt the data (via Kyber Hybrid Encryption for
<a href=#159 id=159 data-nosnippet>159</a>//! keeping the data size to a minimum), then, sending the contents to the adjacent endpoint. By doing this, the private decryption
<a href=#160 id=160 data-nosnippet>160</a>//! key and the contents are kept separate, forcing the hacker to compromise both endpoints.
<a href=#161 id=161 data-nosnippet>161</a>//!
<a href=#162 id=162 data-nosnippet>162</a>//! In order to use the RE-VFS, both endpoints must use the Filesystem backend. Second, the endpoint serving as a storage point
<a href=#163 id=163 data-nosnippet>163</a>//! must accept the inbound file transfer requests, otherwise, the transfer will fail. The example below for the receiving endpoint
<a href=#164 id=164 data-nosnippet>164</a>//! shows how to auto-accept inbound file transfer requests
<a href=#165 id=165 data-nosnippet>165</a>//!
<a href=#166 id=166 data-nosnippet>166</a>//! # Examples
<a href=#167 id=167 data-nosnippet>167</a>//!
<a href=#168 id=168 data-nosnippet>168</a>//! ## Receiving endpoint
<a href=#169 id=169 data-nosnippet>169</a>//! ```
<a href=#170 id=170 data-nosnippet>170</a>//! use citadel_sdk::prelude::*;
<a href=#171 id=171 data-nosnippet>171</a>//! use citadel_sdk::prefabs::server::accept_file_transfer_kernel::AcceptFileTransferKernel;
<a href=#172 id=172 data-nosnippet>172</a>//!
<a href=#173 id=173 data-nosnippet>173</a>//! // this server will listen on 127.0.0.1:25021, and will use the built-in defaults with a kernel
<a href=#174 id=174 data-nosnippet>174</a>//! // that auto-accepts inbound file transfer requests
<a href=#175 id=175 data-nosnippet>175</a>//! let server = DefaultNodeBuilder::default()
<a href=#176 id=176 data-nosnippet>176</a>//! .with_node_type(NodeType::server("127.0.0.1:25021")?)
<a href=#177 id=177 data-nosnippet>177</a>//! .build(AcceptFileTransferKernel::default())?;
<a href=#178 id=178 data-nosnippet>178</a>//!
<a href=#179 id=179 data-nosnippet>179</a>//! // await the server to execute
<a href=#180 id=180 data-nosnippet>180</a>//! # async move {
<a href=#181 id=181 data-nosnippet>181</a>//!     let result = server.await;
<a href=#182 id=182 data-nosnippet>182</a>//! # };
<a href=#183 id=183 data-nosnippet>183</a>//! # Ok::&lt;(), Box&lt;dyn std::error::Error&gt;&gt;(())
<a href=#184 id=184 data-nosnippet>184</a>//! ```
<a href=#185 id=185 data-nosnippet>185</a>//!
<a href=#186 id=186 data-nosnippet>186</a>//! ## Sending endpoint
<a href=#187 id=187 data-nosnippet>187</a>//! ```
<a href=#188 id=188 data-nosnippet>188</a>//! use citadel_sdk::prefabs::client::single_connection::SingleClientServerConnectionKernel;
<a href=#189 id=189 data-nosnippet>189</a>//! use futures::StreamExt;
<a href=#190 id=190 data-nosnippet>190</a>//! use citadel_sdk::prelude::*;
<a href=#191 id=191 data-nosnippet>191</a>//!
<a href=#192 id=192 data-nosnippet>192</a>//! let server_connection_settings = DefaultServerConnectionSettingsBuilder::credentialed_registration("127.0.0.1:25021", "john.doe", "John Doe", "password").build()?;
<a href=#193 id=193 data-nosnippet>193</a>//!
<a href=#194 id=194 data-nosnippet>194</a>//! let client_kernel = SingleClientServerConnectionKernel::new(server_connection_settings, |conn| async move {
<a href=#195 id=195 data-nosnippet>195</a>//!     let virtual_path = "/home/virtual_user/output.pdf";
<a href=#196 id=196 data-nosnippet>196</a>//!     // write the contents with reinforced security.
<a href=#197 id=197 data-nosnippet>197</a>//!     citadel_sdk::fs::write_with_security_level(&amp;conn.remote, "../path/to/input.pdf", SecurityLevel::Reinforced, virtual_path).await?;
<a href=#198 id=198 data-nosnippet>198</a>//!     // read the contents. Reading downloads the file to a local path
<a href=#199 id=199 data-nosnippet>199</a>//!     let stored_local_path = citadel_sdk::fs::read(&amp;conn.remote, virtual_path).await?;
<a href=#200 id=200 data-nosnippet>200</a>//!  
<a href=#201 id=201 data-nosnippet>201</a>//!     Ok(())
<a href=#202 id=202 data-nosnippet>202</a>//! });
<a href=#203 id=203 data-nosnippet>203</a>//!
<a href=#204 id=204 data-nosnippet>204</a>//! let client = DefaultNodeBuilder::default().build(client_kernel)?;
<a href=#205 id=205 data-nosnippet>205</a>//! # async move {
<a href=#206 id=206 data-nosnippet>206</a>//!     let result = client.await;
<a href=#207 id=207 data-nosnippet>207</a>//! # };
<a href=#208 id=208 data-nosnippet>208</a>//! # Ok::&lt;(), Box&lt;dyn std::error::Error&gt;&gt;(())
<a href=#209 id=209 data-nosnippet>209</a>//! ```
<a href=#210 id=210 data-nosnippet>210</a>//!
<a href=#211 id=211 data-nosnippet>211</a>//! [`UdpChannel`]: crate::prelude::UdpChannel
<a href=#212 id=212 data-nosnippet>212</a>//! [`NetKernel`]: crate::prelude::NetKernel
<a href=#213 id=213 data-nosnippet>213</a>//! [`NetKernel::load_remote`]: crate::prelude::NetKernel::load_remote
<a href=#214 id=214 data-nosnippet>214</a>//! [`NetKernel::on_start`]: crate::prelude::NetKernel::on_start
<a href=#215 id=215 data-nosnippet>215</a>//! [`NetKernel::on_node_event_received`]: crate::prelude::NetKernel::on_node_event_received
<a href=#216 id=216 data-nosnippet>216</a>//! [`NetKernel::on_stop`]: crate::prelude::NetKernel::on_stop
<a href=#217 id=217 data-nosnippet>217</a>//! [`KernelExecutor`]: crate::prelude::KernelExecutor
<a href=#218 id=218 data-nosnippet>218</a>//! [`NodeRemote`]: crate::prelude::NodeRemote
<a href=#219 id=219 data-nosnippet>219</a>//! [`NodeRemote::shutdown`]: crate::prelude::NodeRemote::shutdown
<a href=#220 id=220 data-nosnippet>220</a>//! [`NodeType`]: crate::prelude::NodeType
<a href=#221 id=221 data-nosnippet>221</a>//! [`NodeType::Peer`]: crate::prelude::NodeType::Peer
<a href=#222 id=222 data-nosnippet>222</a>//! [`PeerConnectionType`]: crate::prelude::PeerConnectionType
<a href=#223 id=223 data-nosnippet>223</a>//! [`TargetLockedRemote`]: crate::prelude::TargetLockedRemote
<a href=#224 id=224 data-nosnippet>224</a>//! [`PersistenceHandler`]: crate::prelude::PersistenceHandler
<a href=#225 id=225 data-nosnippet>225</a>//! [`SecurityLevel`]: crate::prelude::SecurityLevel
<a href=#226 id=226 data-nosnippet>226</a>//! [`ObjectSource`]: crate::prelude::ObjectSource
<a href=#227 id=227 data-nosnippet>227</a>//! [`NetworkError`]: crate::prelude::NetworkError
<a href=#228 id=228 data-nosnippet>228</a></span><span class="attr">#![forbid(unsafe_code)]
<a href=#229 id=229 data-nosnippet>229</a>#![allow(rustdoc::invalid_html_tags)]
<a href=#230 id=230 data-nosnippet>230</a>#![deny(
<a href=#231 id=231 data-nosnippet>231</a>    clippy::cognitive_complexity,
<a href=#232 id=232 data-nosnippet>232</a>    trivial_numeric_casts,
<a href=#233 id=233 data-nosnippet>233</a>    unused_extern_crates,
<a href=#234 id=234 data-nosnippet>234</a>    unused_import_braces,
<a href=#235 id=235 data-nosnippet>235</a>    variant_size_differences,
<a href=#236 id=236 data-nosnippet>236</a>    unused_features,
<a href=#237 id=237 data-nosnippet>237</a>    unused_results
<a href=#238 id=238 data-nosnippet>238</a>)]
<a href=#239 id=239 data-nosnippet>239</a>
<a href=#240 id=240 data-nosnippet>240</a></span><span class="doccomment">/// Convenience import for building applications
<a href=#241 id=241 data-nosnippet>241</a></span><span class="kw">pub mod </span>prelude {
<a href=#242 id=242 data-nosnippet>242</a>    <span class="kw">pub use </span><span class="kw">crate</span>::backend_kv_store::BackendHandler;
<a href=#243 id=243 data-nosnippet>243</a>    <span class="kw">pub use </span><span class="kw">crate</span>::builder::node_builder::<span class="kw-2">*</span>;
<a href=#244 id=244 data-nosnippet>244</a>    <span class="kw">pub use </span><span class="kw">crate</span>::prefabs::client::peer_connection::PeerConnectionSetupAggregator;
<a href=#245 id=245 data-nosnippet>245</a>    <span class="kw">pub use </span><span class="kw">crate</span>::prefabs::client::PrefabFunctions;
<a href=#246 id=246 data-nosnippet>246</a>    <span class="kw">pub use </span><span class="kw">crate</span>::prefabs::client::{
<a href=#247 id=247 data-nosnippet>247</a>        DefaultServerConnectionSettingsBuilder, ServerConnectionSettings,
<a href=#248 id=248 data-nosnippet>248</a>    };
<a href=#249 id=249 data-nosnippet>249</a>    <span class="kw">pub use </span><span class="kw">crate</span>::prefabs::ClientServerRemote;
<a href=#250 id=250 data-nosnippet>250</a>    <span class="kw">pub use </span><span class="kw">crate</span>::remote_ext::remote_specialization::PeerRemote;
<a href=#251 id=251 data-nosnippet>251</a>    <span class="kw">pub use </span><span class="kw">crate</span>::remote_ext::user_ids::<span class="kw-2">*</span>;
<a href=#252 id=252 data-nosnippet>252</a>    <span class="kw">pub use </span><span class="kw">crate</span>::remote_ext::<span class="kw-2">*</span>;
<a href=#253 id=253 data-nosnippet>253</a>    <span class="kw">pub use </span><span class="kw">crate</span>::responses;
<a href=#254 id=254 data-nosnippet>254</a>    <span class="kw">pub use </span>citadel_proto::prelude::<span class="kw-2">*</span>;
<a href=#255 id=255 data-nosnippet>255</a>    <span class="kw">pub use </span>citadel_types::prelude::<span class="kw-2">*</span>;
<a href=#256 id=256 data-nosnippet>256</a>}
<a href=#257 id=257 data-nosnippet>257</a>
<a href=#258 id=258 data-nosnippet>258</a><span class="doccomment">/// Store data to the backend using this library
<a href=#259 id=259 data-nosnippet>259</a></span><span class="kw">pub mod </span>backend_kv_store;
<a href=#260 id=260 data-nosnippet>260</a><span class="kw">mod </span>builder;
<a href=#261 id=261 data-nosnippet>261</a><span class="doccomment">/// Convenience functions for interacting with the remote encrypted virtual filesystem (RE-VFS)
<a href=#262 id=262 data-nosnippet>262</a></span><span class="kw">pub mod </span>fs;
<a href=#263 id=263 data-nosnippet>263</a><span class="doccomment">/// The prefabs module contains pre-built kernels for common use cases.
<a href=#264 id=264 data-nosnippet>264</a></span><span class="kw">pub mod </span>prefabs;
<a href=#265 id=265 data-nosnippet>265</a><span class="doccomment">/// Extension implementations endowed upon the [NodeRemote](crate::prelude::NodeRemote)
<a href=#266 id=266 data-nosnippet>266</a></span><span class="kw">pub mod </span>remote_ext;
<a href=#267 id=267 data-nosnippet>267</a><span class="doccomment">/// For easy construction of replies to common message types
<a href=#268 id=268 data-nosnippet>268</a></span><span class="kw">pub mod </span>responses;
<a href=#269 id=269 data-nosnippet>269</a><span class="attr">#[doc(hidden)]
<a href=#270 id=270 data-nosnippet>270</a></span><span class="kw">pub mod </span>test_common;
<a href=#271 id=271 data-nosnippet>271</a>
<a href=#272 id=272 data-nosnippet>272</a><span class="attr">#[macro_use]
<a href=#273 id=273 data-nosnippet>273</a></span><span class="kw">pub</span>(<span class="kw">crate</span>) <span class="kw">mod </span>macros;
<a href=#274 id=274 data-nosnippet>274</a>
<a href=#275 id=275 data-nosnippet>275</a><span class="kw">pub use </span>citadel_logging <span class="kw">as </span>logging;
<a href=#276 id=276 data-nosnippet>276</a><span class="doccomment">/// Convenience for SDK users
<a href=#277 id=277 data-nosnippet>277</a></span><span class="kw">pub use </span>citadel_proto::prelude::async_trait;
<a href=#278 id=278 data-nosnippet>278</a><span class="kw">pub use </span>citadel_types <span class="kw">as </span>types;</code></pre></div></section></main></body></html>